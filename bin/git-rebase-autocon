#!/bin/sh -e
#
# Usage: git-rebase-autocon [TARGET] [ARGUMENTS_FOR_GIT_REBASE...]
#
# Rebases the given TARGET while automatically resolving conflicts
# by substituting empty-tree commits labeled "fixup!" that log all
# conflicting hunks in their commit messages in git-diff(1) format.
#
# If TARGET is not specified, the upstream tracking branch is used.
# Optional ARGUMENTS_FOR_GIT_REBASE... are passed to git-rebase(1).
#
# Written in 2010 by Suraj N. Kurapati <https://github.com/sunaku>
# Documented at <https://sunaku.github.io/git-rebase-autocon.html>

# ensure working tree is clean
git rebase HEAD --quiet
commit=$(git rev-parse --short HEAD)

# parse command-line arguments
test $# -gt 0 && target=$1 && shift || target='@{u}'
target=$(git name-rev --name-only "$target")
target=${target#remotes/}

# rebase target and ensure that only merge conflicts made it fail
git rebase "$target" "$@" && exit || test -d .git/rebase-apply

# identify all commits that can be considered as being leftovers
# by searching the reflog for prior versions of the target: each
# version is the HEAD of an alternate branch/timeline of history
leftovers=$(git reflog --format='%gd%gs' |
            sed -n "s|rebase: checkout $target$||p" |
            xargs git rev-list 2>/dev/null || :)

# solve merge conflicts by absorbing leftover commits from prior
# versions of the target or by setting aside conflicting commits
trap 'git rebase --abort' TERM INT
while test -d .git/rebase-apply; do
  conflict=$(cat .git/rebase-apply/original-commit)
  headline=$(head -1 .git/rebase-apply/final-commit)
  callout="$(git rev-parse --short "$conflict") $headline"

  if test -n "$leftovers" && echo "$leftovers" | grep -F -q "$conflict"
  then echo "git-rebase-autocon: absorbing leftover commit: $callout"
  else echo "git-rebase-autocon: resolving conflict commit: $callout"

    # in place of each conflicting commit, record an empty commit whose
    # message contains the changes introduced by the conflicting commit
    git reset --mixed --quiet # empty the index so we can make a commit
    git commit --allow-empty --reuse-message="$conflict" --quiet
    {
      printf 'fixup! %s\n\n' "$callout"
      git format-patch --stdout -- "$conflict~..$conflict"
    } |
    git commit --amend --allow-empty --file=- --quiet

    were_any_commits_set_aside_to_resolve_conflicts=true
  fi

  git rebase --skip >/dev/null 2>&1 || :
done

if ${were_any_commits_set_aside_to_resolve_conflicts:-false}; then cat <<END

    +-------------------------IMPORTANT!----------------------------+
    |                                                               |
    | Some of YOUR COMMITS WERE SET ASIDE to solve merge conflicts: |
    | empty commits labeled as "fixup!" have now taken their place. |
    | But rest assured, THEY STILL EXIST in Git history at $commit, |
    | and your working tree has all changes from those commits too! |
    |                                                               |
    | You can UNDO THIS REBASE at any time by running this command: |
    |                                                               |
    |                  git reset --hard $commit                     |
    |                                                               |
    | You can SEE WHAT CHANGED from before by running this command: |
    |                                                               |
    |                      git diff $commit                         |
    |                                                               |
    +-------------------------IMPORTANT!----------------------------+

END
fi
